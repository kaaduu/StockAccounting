plugins {
  id 'java'
  id 'application'
}

group = 'cz.datesoft'
version = 'dev'

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(17)
  }
}

// Compile with Java 17 bytecode level.
tasks.withType(JavaCompile).configureEach {
  options.release = 17
}

tasks.withType(JavaExec).configureEach {
  javaLauncher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(17)
  }
}

repositories {
  // Offline-friendly: we use local libjar/*.jar, no remote repos needed.
}

sourceSets {
  main {
    java {
      srcDirs = ['src']
    }
    resources {
      srcDirs = ['src']
      exclude '**/*.java'
      // Generated by Gradle task (avoid duplicate with legacy file).
      exclude 'version.properties'
    }
  }
}

dependencies {
  implementation fileTree(dir: 'libjar', include: ['*.jar'], exclude: ['*debug*.jar'])
  runtimeOnly fileTree(dir: 'libjar', include: ['*.jar'], exclude: ['*debug*.jar'])
}

application {
  mainClass = 'cz.datesoft.stockAccounting.Main'
}

tasks.named('jar') {
  archiveFileName = 'StockAccounting.jar'
  manifest {
    attributes(
        'Main-Class': application.mainClass.get()
    )
  }
}

def generatedVersionDir = layout.buildDirectory.dir('generated-resources/version')

tasks.register('generateVersionProperties') {
  outputs.dir(generatedVersionDir)

  doLast {
    def outDir = generatedVersionDir.get().asFile
    outDir.mkdirs()
    def versionFile = new File(outDir, 'version.properties')

    def v = 'dev-build'
    try {
      def proc = ['git', 'describe', '--tags', '--always'].execute(null, project.rootDir)
      def text = proc.text?.trim()
      if (proc.waitFor() == 0 && text) {
        v = text
      }
    } catch (Exception ignored) {
      // Keep dev-build
    }

    versionFile.text = "version=${v}\n"
  }
}

tasks.named('processResources') {
  dependsOn tasks.named('generateVersionProperties')
  from(generatedVersionDir)
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
